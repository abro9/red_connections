
<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Reddit Connections</title>

<!-- JavaScript Libraries //-->
<script src="https://d3js.org/d3.v3.min.js"></script>

<!-- CSS Style //-->
<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,900|Source+Code+Pro:300" rel="stylesheet" type="text/css">
<style>
body {
    font-family: 'Source Sans Pro', sans-serif;
    font-weight: 300;
}

b {
    font-weight: 900;
}

.outline {
    fill: none;
    stroke: #888888;
    stroke-width: 1px;
}

#tooltip {
    font-size: 10pt;
    font-weight: 900;

    fill: #000000;
    stroke: #ffffff;
    stroke-width: 0.25px;
}

.node {
    stroke: #ffffff;
    stroke-weight: 1px;
}

.link {
    fill: none;
    stroke: #888888;
    stroke-weight: 1px;
    stroke-opacity: 0.5;
}

.highlight {
    stroke: red;
    stroke-weight: 4px;
    stroke-opacity: 1.0;
}
</style>

<script>
var width  = 1200;
var height = 800;
var margin = 20;
var pad = margin / 2;
var color = d3.scale.category20();
// Generates a tooltip for a SVG circle element based on its ID
function addTooltip(circle) {
    var x = parseFloat(circle.attr("cx"));
    var y = parseFloat(circle.attr("cy"));
    var r = parseFloat(circle.attr("r"));
    var text = circle.attr("id");
    var tooltip = d3.select("#plot")
        .append("text")
        .text(text)
        .attr("x", x)
        .attr("y", y)
        .attr("dy", -r * 2)
        .attr("id", "tooltip");
    var offset = tooltip.node().getBBox().width / 2;
    if ((x - offset) < 0) {
        tooltip.attr("text-anchor", "start");
        tooltip.attr("dx", -r);
    }
    else if ((x + offset) > (width - margin)) {
        tooltip.attr("text-anchor", "end");
        tooltip.attr("dx", r);
    }
    else {
        tooltip.attr("text-anchor", "middle");
        tooltip.attr("dx", 0);
    }
}
var vis = d3.select("#chart")
  .append("svg:svg")
    .attr("width", w)
    .attr("height", h)
    .attr("pointer-events", "all")
  .append('svg:g')
    .call(d3.behavior.zoom().on("zoom", redraw))
  .append('svg:g');
vis.append('svg:rect')
    .attr('width', w)
    .attr('height', h)
    .attr('fill', 'white');
function redraw() {
  console.log("here", d3.event.translate, d3.event.scale);
  vis.attr("transform",
      "translate(" + d3.event.translate + ")"
      + " scale(" + d3.event.scale + ")");
}
function drawGraph(graph) {
    var svg = d3.select("#force").append("svg")
        .attr("width", width)
        .attr("height", height);
    // draw plot background
    svg.append("rect")
        .attr("width", width)
        .attr("height", height)
        .style("fill", "#eeeeee");
    // create an area within svg for plotting graph
    var plot = svg.append("g")
        .attr("id", "plot")
        .attr("transform", "translate(" + pad + ", " + pad + ")");
    // https://github.com/mbostock/d3/wiki/Force-Layout#wiki-force
    var layout = d3.layout.force()
        .size([width - margin, height - margin])
        .charge(-120)
        .linkDistance(function(d, i) {
            //return (d.source.group == d.target.group) ? 50 : 100;
            return d.lval < 500 ? d.lval : 500;
        })
        .nodes(graph.nodes)
        .links(graph.links)
        .start();
    drawLinks(graph.links);
    drawNodes(graph.nodes);
    // add ability to drag and update layout
    // https://github.com/mbostock/d3/wiki/Force-Layout#wiki-drag
    d3.selectAll(".node").call(layout.drag);
    // https://github.com/mbostock/d3/wiki/Force-Layout#wiki-on
    layout.on("tick", function() {
        d3.selectAll(".link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
        d3.selectAll(".node")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    });
}
    function tick(e) {
  // Push different nodes in different directions for clustering.
  var k = 6 * e.alpha;
  graph.nodes.forEach(function(o, i) {
    o.y += i & 1 ? k : -k;
    o.x += i & 2 ? k : -k;
  });
  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}
// Draws nodes on plot
function drawNodes(nodes) {
    // used to assign nodes color by group
    var color = d3.scale.category20();
    // https://github.com/mbostock/d3/wiki/Force-Layout#wiki-nodes
    d3.select("#plot").selectAll(".node")
        .data(nodes)
        .enter()
        .append("circle")
        .attr("class", "node")
        .attr("id", function(d, i) { return d.name; })
        .attr("cx", function(d, i) { return d.x; })
        .attr("cy", function(d, i) { return d.y; })
        .attr("r",  function(d, i) { return 4; })
        .style("fill",   function(d, i) { return color(d.group); })
        .on("mouseover", function(d, i) { addTooltip(d3.select(this)); })
        .on("mouseout",  function(d, i) { d3.select("#tooltip").remove(); });
}
// Draws edges between nodes
function drawLinks(links) {
    var scale = d3.scale.linear()
        .domain(d3.extent(links, function(d, i) {
           return d.value;
        }))
        .range([1, 6]);
    // https://github.com/mbostock/d3/wiki/Force-Layout#wiki-links
    d3.select("#plot").selectAll(".link")
        .data(links)
        .enter()
        .append("line")
        .attr("class", "link")
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; })
        .style("stroke-width", function(d, i) {
            //return scale(d.value) + "px";
            return (d.draw) ? (scale(d.value) + "px") : 0;
        })
        .style("stroke-dasharray", function(d, i) {
            return (d.value <= 1) ? "2, 2" : "none";
        });
}
</script>
</head>

<body>
<h1 align="center"> Reddit Connections </h1>
<p align="center">Alexander Brown</p> <br>

<div align="center" id="force"></div>
<p align="center">A visualization of connections for 150 subreddits based upon 2000 unique users who were active in the 'Popular' multi-subreddit</p> <br>

<div style="margin-left: 10%; margin-right: 10%">
<h2>About</h2>
<p>This is a project I've created with the goal of visualizing connections between Reddit subreddits. I think that Reddit is full of fascinating communities, and I was interested in understanding more about the relationships between them.</p> <br>

<h2>Methods</h2> 
<h3>Data Collection</h3> 
<p>The data collection process occurs in two main steps. First, usernames are grabbed from new posts from <a href="https://www.reddit.com/r/popular/">/r/popular</a> and <a href="https://www.reddit.com/r/all/">/r/all</a>. Then, I scrape each user's history to determine their number of submissions and posts in each subreddit. These tasks are both done using <a href="http://praw.readthedocs.io/en/latest/index.html#">PRAW</a>, the Python Reddit API Wrapper.</p>

<p>This data collection must be a fairly continuous task if I am to gather a significant amount of information. Fortunately, I have a Raspberry Pi from past projects. I've established several Cron-jobs there to collect data for thousands of users automatically each day.</p>

<h3>Analysis</h3> 
<p>After I've collected some data, the next task is to calculate the connection strength between each subreddit. This is done in two parts.</p>

<p>First, I calculate the connection strength between each subreddit that an individual user has been active in. This connection strength is currently a simple summation of proportions of the user's posts and comments within the two subreddits. Next, I sum these pair connection strengths across all users to generate the cummulative connection strength for each pair.</p>

<h3>Visualization</h3> 
<p>I'm currently using <a href="https://d3js.org/">D3</a> to build a force-directed network graph. The width and tension of each link is determined by its previously calculated connection strength. Each node has a maximum of 15 connections with other nodes. However, only the 5 strongest connections are potentially displayed for each node. This is to reduce processing requirements and improve readability, while maintaining an accurate representation of the network.</p>

<p>I am inexperienced with JavaScript, so my implementation is fairly simple as of now. However, as I learn more, I plan on making the network graph more interactive and browsable.</p> <br>

<h2>Resources</h2>
<h3>Data Collection</h3>
<ul> 
  <li><a href="http://praw.readthedocs.io/en/latest/index.html">PRAW info</a></li>
  <li><a href="http://pythonforengineers.com/build-a-reddit-bot-part-1/">Reddit bot walkthru</a></li>
</ul>

<h3>Math</h3>
<ul> 
  <li><a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">Force-directed graph drawing</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Community_structure">Wikipedia - Community Structure</a></li>
  <li><a href="https://arxiv.org/abs/1009.0638">Clique Graphs and Overlapping Communities</a></li>
</ul>

<h3>Visualization</h3> 
<ul> 
  <li><a href="https://github.com/d3/d3-force">d3-force</a></li>
  <li><a href="https://plot.ly/python/3d-network-graph/">Plotly - another potential tool</a></li>
</ul>

<br>
<br>

</div>


<script>
d3.json("pcap_export.json", drawGraph);
</script>
</body>
</html>